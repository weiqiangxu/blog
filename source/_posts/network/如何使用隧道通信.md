---
title: 如何使用隧道通信
index_img: /images/bg/network.png
banner_img: /images/bg/computer.jpeg
tags:
  - network
categories:
  - network
date: 2023-07-02 18:40:12
excerpt: 使用docker构建隧道进行通信
sticky: 1
hide: true
---

1. 什么事VXLAN

一种网络虚拟化技术

2. GRE隧道是什么

一种隧道协议。（将原始的数据包封装在一个新的IP头中实现跨越多个网络端口传输）

3. 两者之间的关系是什么

在VXLAN网络中，通过使用GRE隧道技术可以实现虚拟网络之间的隔离。

4. 原理

GRE协议将原始的数据包封装在一个新的IP头中，使得数据包能够跨越多个网络端口传输。（借助IP协议中的IP数据报文来传输数据）


5. 实践


``` bash
ip link add vxlan1 type vxlan id 100 dstport 4789 remote 10.0.0.1 dev eth0
ip a
ip link add vxlan2 type vxlan id 200 dstport 4789 remote 10.0.0.2 dev eth0
ip link set dev vxlan1 up
ip link set dev vxlan2 up
ip a
ip addr add 192.168.1.1/24 dev vxlan1
ip addr add 192.168.2.1/24 dev vxlan2
ip a
ping 192.168.2.1
```


两个网络命名空间，如何建立vxlan实现网络隔离

``` bash
# 创建网络命名空间
brctl addbr br-test

ip netns help
ip netns list
ip netns add a
ip netns add b
ip netns add c
ip netns add d


ip netns exec a ip link add vxlan0 type vxlan id 100 dev eth0 dstport 4789
ip netns exec b ip link add vxlan0 type vxlan id 100 dev eth0 dstport 4789
ip netns exec c ip link add vxlan0 type vxlan id 200 dev eth0 dstport 4789
ip netns exec d ip link add vxlan0 type vxlan id 200 dev eth0 dstport 4789


ip netns exec a ip link add br-test type bridge
ip netns exec b ip link add br-test type bridge
ip netns exec c ip link add br-test type bridge
ip netns exec d ip link add br-test type bridge

ip netns exec a ip link set vxlan0 master br-test
ip netns exec b ip link set vxlan0 master br-test
ip netns exec c ip link set vxlan0 master br-test
ip netns exec d ip link set vxlan0 master br-test


ip netns exec a ip addr add 192.168.1.1/24 dev vxlan0
ip netns exec b ip addr add 192.168.1.2/24 dev vxlan0
ip netns exec c ip addr add 192.168.2.1/24 dev vxlan0
ip netns exec d ip addr add 192.168.2.2/24 dev vxlan0


ip netns exec a ip link set dev vxlan0 up
ip netns exec b ip link set dev vxlan0 up
ip netns exec c ip link set dev vxlan0 up
ip netns exec d ip link set dev vxlan0 up


ip netns exec a iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.2.0/24 -j DROP
ip netns exec c iptables -A FORWARD -s 192.168.2.0/24 -d 192.168.1.0/24 -j DROP
```


要使用VXLAN实现这个网络隔离的需求，可以按照以下步骤进行配置：

1. 在每个命名空间上创建一个VXLAN设备，例如vxlan0：
```
ip netns exec a ip link add vxlan0 type vxlan id 100 dev eth0 dstport 4789
ip netns exec b ip link add vxlan0 type vxlan id 100 dev eth0 dstport 4789
ip netns exec c ip link add vxlan0 type vxlan id 200 dev eth0 dstport 4789
ip netns exec d ip link add vxlan0 type vxlan id 200 dev eth0 dstport 4789
```

2. 将VXLAN设备连接至同一网桥，例如br0：
```
ip netns exec a ip link set vxlan0 master br0
ip netns exec b ip link set vxlan0 master br0
ip netns exec c ip link set vxlan0 master br0
ip netns exec d ip link set vxlan0 master br0
```

3. 为VXLAN设备配置IP地址，确保a和b、c和d在不同IP段中：
```
ip netns exec a ip addr add 192.168.1.1/24 dev vxlan0
ip netns exec b ip addr add 192.168.1.2/24 dev vxlan0
ip netns exec c ip addr add 192.168.2.1/24 dev vxlan0
ip netns exec d ip addr add 192.168.2.2/24 dev vxlan0
```

4. 启动VXLAN设备：
```
ip netns exec a ip link set dev vxlan0 up
ip netns exec b ip link set dev vxlan0 up
ip netns exec c ip link set dev vxlan0 up
ip netns exec d ip link set dev vxlan0 up
```

5. 禁止a和b、c和d之间的直接通信，只允许各自命名空间内的通信：
```
ip netns exec a iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.2.0/24 -j DROP
ip netns exec c iptables -A FORWARD -s 192.168.2.0/24 -d 192.168.1.0/24 -j DROP
```

完成以上配置后，a和b之间可以互相访问，c和d之间也可以互相访问，但是a和b与c和d之间不能互相访问。


``` bash 




# ping [Remote IP]

# ip tunnel add gre0 mode gre remote [Remote IP] local [Local IP] ttl 255

# ip link set dev gre0 up

# ip route add [Network] via [Local IP] dev gre0

# ping [Remote IP]
```


1. 使用docker创建none网络
2. 再使用隧道进行通讯


[如何利用GRE隧道建立VXLAN](https://www.wxkcg.com/gre/greb74bf1660464437abf112f3752358332)






要实现VXLAN网络隔离，需要使用Linux中的网络命名空间来创建多个隔离的虚拟网络环境，并将VXLAN设备连接到相应的命名空间。以下是一个完整的示例，包括创建网络命名空间、配置VXLAN设备、添加主机路由和防火墙规则：

1. 创建网络命名空间：
```
ip netns add ns1
ip netns add ns2
```

2. 创建VXLAN设备：
```
ip link add vxlan0 type vxlan id 1000 group 239.0.0.1 dev eth0
```
其中，VNI（VXLAN网络标识符）为1000，组播组IP地址为239.0.0.1，底层网络接口为eth0。

3. 设置VXLAN设备的IP地址：
```
ip netns exec ns1 ip addr add 192.168.1.1/24 dev vxlan0
ip netns exec ns2 ip addr add 192.168.1.2/24 dev vxlan0
```
分别将192.168.1.1/24和192.168.1.2/24的IP地址分配给ns1和ns2命名空间中的VXLAN设备。

4. 开启VXLAN设备：
```
ip link set up dev vxlan0
```

5. 将VXLAN设备连接到相应的命名空间：
```
ip link set vxlan0 netns ns1
ip link set vxlan0 netns ns2
```
将vxlan0设备分别连接到ns1和ns2命名空间。

6. 添加主机路由：
```
ip netns exec ns1 ip route add default via 192.168.1.1 dev vxlan0
ip netns exec ns2 ip route add default via 192.168.1.2 dev vxlan0
```
分别为ns1和ns2命名空间添加默认路由。

7. 添加防火墙规则实现隔离：
```
ip netns exec ns1 iptables -A OUTPUT -j DROP
ip netns exec ns2 iptables -A OUTPUT -j DROP
```
禁止ns1和ns2命名空间中的主机发送任何流量。

请注意，上述示例中的IP地址和网络参数需要根据实际情况进行修改和配置。此外，还可能需要进行其他网络配置，如设置ARP代理和配置VXLAN设备的MTU等。







### 使用隧道建立点对点通信

![点对点隧道通讯](/images/dianduidian.jpeg)

``` bash
yum install -y bridge-utils
ip netns add container1
ip netns add container2
ip netns list
ip link add veth1 type veth peer name veth2
ip link add veth3 type veth peer name veth4
ip link set veth2 netns container1
ip link set veth4 netns container2
ip netns exec container1 ip addr add 10.1.1.5/24 dev veth2
ip netns exec container1 ip link set veth2 up
ip netns exec container1 ip route add default via 10.1.1.1
ip netns exec container2 ip addr add 10.1.1.7/24 dev veth4
ip netns exec container2 ip link set veth4 up
ip netns exec container2 ip route add default via 10.1.1.1
brctl addbr br-link
brctl addif br-link veth1
brctl addif br-link veth3
ip link set veth1 up
ip link set veth3 up
ip addr add 10.1.1.1/24 dev br-link
ip link set br-link up
```

``` bash
ip netns exec container1 ip link delete vxlan0
ip netns exec container1 ip link add vxlan0 type vxlan \
    id 42 \
    dstport 4789 \
    remote 10.1.1.7 \
    local 10.1.1.5 \
    dev veth2
ip netns exec container1 ip -d link 
ip netns exec container1 ip addr add 172.1.1.2/24 dev vxlan0
ip netns exec container1 ip link set vxlan0 up
ip netns exec container1 ip route
ip netns exec container1 bridge fdb


ip netns exec container2 ip link delete vxlan0
ip netns exec container2 ip link add vxlan0 type vxlan \
    id 42 \
    dstport 4789 \
    remote 10.1.1.5 \
    local 10.1.1.7 \
    dev veth4
ip netns exec container2 ip -d link 
ip netns exec container2 ip addr add 172.1.1.3/24 dev vxlan0
ip netns exec container2 ip link set vxlan0 up
ip netns exec container2 ip route
ip netns exec container2 bridge fdb
ip netns exec container1 ping 172.1.1.3
```


### 多播vxlan

![多播网络](/images/duobovxlan.jpeg)

``` bash
yum install -y bridge-utils
ip netns add container1
ip netns add container2
ip netns list
ip link add veth1 type veth peer name veth2
ip link add veth3 type veth peer name veth4
ip link set veth2 netns container1
ip link set veth4 netns container2
ip netns exec container1 ip addr add 10.1.1.5/24 dev veth2
ip netns exec container1 ip link set veth2 up
ip netns exec container1 ip route add default via 10.1.1.1
ip netns exec container2 ip addr add 10.1.1.7/24 dev veth4
ip netns exec container2 ip link set veth4 up
ip netns exec container2 ip route add default via 10.1.1.1
brctl addbr br-link
brctl addif br-link veth1
brctl addif br-link veth3

ip link set veth1 up
ip link set veth3 up

ip addr add 10.1.1.1/24 dev br-link
ip link set br-link up
```

``` bash
ip netns exec container1 ip link delete vxlan0
ip netns exec container1 ip link add vxlan0 type vxlan \
    id 42 \
    dstport 4789 \
    group 239.1.1.1 \
    dev veth2
ip netns exec container1 ip -d link 
ip netns exec container1 ip addr add 172.1.1.2/24 dev vxlan0
ip netns exec container1 ip link set vxlan0 up
ip netns exec container1 ip route
ip netns exec container1 bridge fdb
ip netns exec container2 ip link delete vxlan0
ip netns exec container2 ip link add vxlan0 type vxlan \
    id 42 \
    dstport 4789 \
    group 239.1.1.1 \
    dev veth4
ip netns exec container2 ip -d link 
ip netns exec container2 ip addr add 172.1.1.3/24 dev vxlan0
ip netns exec container2 ip link set vxlan0 up
ip netns exec container2 ip route
ip netns exec container2 bridge fdb
ip netns exec container1 ping 172.1.1.3
```

#### 多播网络下的数据路径

[https://cizixs.com/2017/09/28/linux-vxlan/](https://cizixs.com/2017/09/28/linux-vxlan/)

1. 上面添加type vxlan的时候填写的remote最终会配置到 FDB 表之中,这表的VTEP 的地址可以决定arp查找mac地址的数据走向
2. 可以手动维护 fdb 表 `bridge fdb append 52:5e:55:58:9a:ab dev vxlan0 dst 192.168.8.101`
3. 手动维护 ARP 表 `ip neigh add 10.20.1.3 lladdr d6:d9:cd:0a:a4:28 dev vxlan0`

### 利用bridge实现更复杂的多播网络

其实就是上面的，在一个宿主机上可以建设多个bridge，每个bridge上面负责一个vxlan的网络。

![多VXLAN下面的网络](/images/duovxlanwangluo.jpeg)

> 主机会根据 VNI 来区别不同的 vxlan 网络，不同的 vxlan 网络之间不会相互影响。如果再加上 network namespace，就能实现更复杂的网络结构
> 主机会根据 VNI 来区别不同的 vxlan 网络，不同的 vxlan 网络之间不会相互影响。如果再加上 network namespace，就能实现更复杂的网络结构
> 主机会根据 VNI 来区别不同的 vxlan 网络，不同的 vxlan 网络之间不会相互影响。如果再加上 network namespace，就能实现更复杂的网络结构


### 相关文档

[https://cizixs.com/2017/09/28/linux-vxlan/](https://cizixs.com/2017/09/28/linux-vxlan/)