---
title: 配置解析
index_img: /images/prometheus_icon.jpeg
tags:
  - prometheus
categories:
  - prometheus
date: 2023-04-08 06:40:12
---

[官网配置解析](https://prometheus.io/docs/prometheus/latest/configuration/configuration/)

```
全局配置      global
告警配置      alerting
规则文件配置   rule_files
拉取配置       scrape_configs
远程读写配置   remote_read、remote_write
```

### 默认配置

```
global:
  scrape_interval: 15s # 将刮擦间隔设置为每15秒。默认为1分钟一次
  evaluation_interval: 15s # 每15秒评估一次规则。默认为1分钟。
  # Scrape_timeout被设置为全局默认值(10秒)。

# 告警配置
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          # - alertmanager:9093

# 加载规则一次，并定期根据全局的“evaluation_interval”计算它们
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

# 一个抓取配置，只包含一个要抓取的端点:这里是Prometheus本身
scrape_configs:
  # 作业名称作为标签' job=<job_name> '添加到从此配置中提取的任何时间序列中
  - job_name: "prometheus"

    # Metrics_path默认为“/metrics”
    # scheme defaults to 'http'.

    static_configs:
      - targets: ["localhost:9090"]
```

[Prometheus之配置详解](https://www.cnblogs.com/wangguishe/p/15598120.html)

### 配置样式

```
# 默认情况下分配给抓取指标的作业名称
job_name: <job_name>

# 从这项工作中获取目标的频率
[ scrape_interval: <duration> | default = <global_config.scrape_interval> ]

# 每次抓取作业时超时
[ scrape_timeout: <duration> | default = <global_config.scrape_timeout> ]

# 从目标获取指标的HTTP资源路径
[ metrics_path: <path> | default = /metrics ]

# honor_labels控制Prometheus如何处理标签之间的冲突已经存在于采集的数据和普罗米修斯将附加的标签中
服务器端(“作业”和“实例”标签，手动配置的目标 
标签，以及服务发现实现生成的标签)
#
# 如果将honor_labels设置为“true”，则通过保留抓取数据中的标签值并忽略冲突的服务器端标签来解决标签冲突
#
# 如果将honor_labels设置为“false”，则通过将刮取数据中的冲突标签重命名为“exported_<original-label>”(例如“exported_instance”，“exported_job”)，然后附加服务器端标签来解决标签冲突。
#
# 将honor_labels设置为“true”对于federation和抓取Pushgateway等用例很有用，在这些用例中，应该保留目标中指定的所有标签
#
# 注意，任何全局配置的“external_labels”都不受此设置的影响。在与外部系统的通信中，它们总是只在时间序列还没有给定标签时才被应用，否则将被忽略。[honor_labels: <boolean> | default = false]
#  honor_timestamps控制Prometheus是否尊重抓取数据中的时间戳。
#
# 如果honor_timestamps设置为“true”，则将使用目标公开的度量的时间戳
#
# 如果honor_timestamps设置为“false”，则目标暴露的度量标准的时间戳将被忽略
[ honor_timestamps: <boolean> | default = true ]

# 配置用于请求的协议方案.
[ scheme: <scheme> | default = http ]

# 可选HTTP URL参数.
params:
  [ <string>: [<string>, ...] ]

# 使用配置的用户名和密码在每个抓取请求上设置“授权”报头。
# “Password”和“password_file”互斥。
basic_auth:
  [ username: <string> ]
  [ password: <secret> ]
  [ password_file: <string> ]

# 使用配置的凭证在每个抓取请求上设置“Authorization”标头。
authorization:
  # 设置请求的身份验证类型。
  [ type: <string> | default: Bearer ]
  # 设置请求的凭据。它与' credentials_file '互斥。
  [ credentials: <secret> ]
  # 使用从配置文件读取的凭据设置请求的凭据。它与“凭证”是互斥的。
  [ credentials_file: <filename> ]

# Optional OAuth 2.0 configuration.
# 不能与basic_auth或authorization同时使用:
  [ <oauth2> ]

#配置抓取请求是否遵循HTTP 3xx重定向
[ follow_redirects: <boolean> | default = true ]

# Whether to enable HTTP2.
[ enable_http2: <bool> | default: true ]

# Configures the scrape request's TLS settings.
tls_config:
  [ <tls_config> ]

# Optional proxy URL.
[ proxy_url: <string> ]
# Comma-separated string that can contain IPs, CIDR notation, domain names
# that should be excluded from proxying. IP and domain names can
# contain port numbers.
[ no_proxy: <string> ]
# Use proxy URL indicated by environment variables (HTTP_PROXY, https_proxy, HTTPs_PROXY, https_proxy, and no_proxy)
[ proxy_from_environment: <bool> | default: false ]
# Specifies headers to send to proxies during CONNECT requests.
[ proxy_connect_header:
  [ <string>: [<secret>, ...] ] ]

# 大于这个字节数的未压缩响应体将导致抓取失败。0表示没有限制。例子:100 mb。这是一个实验性的特征，这种行为可能会改变或在未来被删除
[ body_size_limit: <size> | default = 0 ]

# 每次取样将被接受的取样数量限制。如果在重新贴上公制标签后存在超过这个数量的样品，整个刮擦将被视为失败。0表示没有限制
[ sample_limit: <int> | default = 0 ]

# 每次刮取样品所接受的标签数量的限制。如果在度量重标记后出现了超过这个数量的标签，整个抓取将被视为失败。0表示没有限制
[ label_limit: <int> | default = 0 ]

# 每次刮取标签名称的长度限制，将被接受为一个样品。如果标签名比标尺重标记后的这个数字长，整个抓取将被视为失败。0表示没有限制
[ label_name_length_limit: <int> | default = 0 ]

# 每次刮取标签值的长度限制，将被接受为一个样品。如果一个标签值大于这个数值，那么整个抓取将被视为失败。0表示没有限制
[ label_value_length_limit: <int> | default = 0 ]

# 每次抓取配置将接受的唯一目标数量的限制。如果在重新标记目标后存在超过这个数量的目标，普罗米修斯将把目标标记为失败而不删除它们。0表示没有限制。这是一个实验性的特征，这种行为在未来可能会改变。
[ target_limit: <int> | default = 0 ]
Where<job_name>在所有抓取配置中必须是唯一的。

<tls_config>
Atls_config允许配置 TLS 连接。

# CA certificate to validate API server certificate with.
[ ca_file: <filename> ]

# Certificate and key files for client cert authentication to the server.
[ cert_file: <filename> ]
[ key_file: <filename> ]

# ServerName extension to indicate the name of the server.
# https://tools.ietf.org/html/rfc4366#section-3.1
[ server_name: <string> ]

# Disable validation of the server certificate.
[ insecure_skip_verify: <boolean> ]

# 最小可接受TLS版本。接受值:TLS10 (TLS 1.0)， TLS11 (TLS 1.1)， TLS12 (TLS 1.2)， TLS13 (TLS 1.3)如果未设置，Prometheus将使用Go默认的最小版本，即TLS 1.2。详见MinVersion网站https://pkg.go.dev/crypto/tls#Config。
[ min_version: <string> ]

# 最大可接受TLS版本。接受值:TLS10 (TLS 1.0)、TLS11 (TLS 1.1)、TLS12 (TLS 1.2)、TLS13 (TLS 1.3)。如果未设置，Prometheus将使用Go默认的最大版本，即TLS 1.3。参见https://pkg.go.dev/crypto/tls#Config中的MaxVersion
[ max_version: <string> ]
<oauth2>
使用客户端凭据授权类型的 OAuth 2.0 身份验证。Prometheus 使用给定的客户端访问和密钥从指定端点获取访问令牌。

client_id: <string>
[ client_secret: <secret> ]

# 从文件中读取客户端秘密。它与' client_secret '互斥。
[ client_secret_file: <filename> ]

# Scopes for the token request.
scopes:
  [ - <string> ... ]

# The URL to fetch the token from.
token_url: <string>

# Optional parameters to append to the token URL.
endpoint_params:
  [ <string>: <string> ... ]

# Configures the token request's TLS settings.
tls_config:
  [ <tls_config> ]

# 可选代理URL
[ proxy_url: <string> ]

# 逗号分隔的字符串，可以包含ip, CIDR表示法，域名，应排除代理。IP和域名可以包含端口号
[ no_proxy: <string> ]

# 使用由环境变量指示的代理URL (HTTP_PROXY、https_proxy、https_proxy、https_proxy和no_proxy)
[ proxy_from_environment: <bool> | default: false ]

# 指定在CONNECT请求期间发送给代理的头。
[ proxy_connect_header:
  [ <string>: [<secret>, ...] ] ]
```